---
title: "DPH_Documentation"
author: "Caroline Devlin"
date: "11/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# States, Parameters, and State Equations (Written Format)

Should the GA Department of Public Health need to make modifications in the code later on to reflect changes regarding new information about the Covid-19 virus, these changes should also be reflected in the following sections. For instance, if DPH decides to add additional states (and their equations) / parameters to the model, they should be defined in the following section using the same format. This section is solely for readability purposes and does not influence the inputs of the code or the results produced by the code. 

## States

The model created considers various states to describe a student's status as it relates to Covid-19 infection. The states are as follows:

$S_v$: susceptible and vaccinated

$S_n$: susceptible and not vaccinated

$I_{a,v}$: infected, asymptomatic, and vaccinated

$I_{a,n}$: infected, asymptomatic, and not vaccinated

$I_{s,v}$: infected, symptomatic, and vaccinated

$I_{s,n}$: infected, symptomatic, and not vaccinated

$TFN_{a(s)}$: infected and asymptomatic (symptomatic), has been tested with false negative results

$TISO^+_{a(s)}$: infected and asymptomatic (symptomatic), has been tested and currently in isolation

$TISO^-_{a(s)}$: infected and asymptomatic (symptomatic), has been tested and currently not in isolation

$RC$: recovered and confirmed, i.e., has been diagnosed previously

$RU$: recovered and unknown, i.e., has not been diagnosed previously


## Parameters

Below are the variable definitions

|          Parameter         |                                             Description                                             |           Value          |
|:--------------------------:|:---------------------------------------------------------------------------------------------------:|:------------------------:|
|         $\beta_1$          | Transmission rate due to contact between susceptible, vaccinated and asymptomatic infected          |            0.068         |
|         $\beta_2$          | Transmission rate due to contact between susceptible, vaccinated and symptomatic infected           |            0.136         |
|         $\beta_3$          | Transmission rate due to contact between susceptible, not vaccinated and asymptomatic infected      |            0.2           |
|         $\beta_4$          | Transmission rate due to contact between susceptible, not vaccinated and symptomatic infected       |            0.4           |
|          $\gamma$          |                              Rate of recovery of an infected individual                             |            0.1           |
|            $p_0$           |                            Proportion of infections that are symptomatic                            |            0.7           |
|         $C_a$,$C_s$        |        Isolation compliance rate for asymptomatic/symptomatic infected and tested individuals       |            1, 1          |
|  $FN_{pcr_a}$,$FN_{pcr_s}$ |               False negative rate of a PCR test for asymptomatic/symptomatic patients               |         14.9%, 14.9%     |
| $FN_{rap_a}$, $FN_{rap_s}$ |              False negative rate of a rapid test for asymptomatic/symptomatic patients              |         37%, 37%         |
| $FP_{pcr_a}$, $FP_{pcr_s}$ |               False positive rate of a PCR test for asymptomatic/symptomatic patients               |          5%, 5%          |
| $FP_{rap_a}$, $FP_{rap_s}$ |               False positive ate of a rapid test for asymptomatic/symptomatic patients              |         10%, 10%         |
|          $T_{pcr}$         |                         Percentage of students that have access to PCR tests                        | Defined in each scenario |
|  $T_{rap_a}$, $T_{rap_s}$  |                    Percentage of students that have access to rapid antigen tests                   | Defined in each scenario |
|          $MC$              |                    Level of mask efficacy dependent on school's masking policy                      | Defined in each scenario |
|          $VR_s$            |                    Vaccination Rate of students in school defined by school administrator           | Defined in each scenario |
|          $VR_f$            |                    Vaccination Rate of students in school defined by school administrator           | Defined in each scenario |


## State Equations

The following equations describe the fraction of individuals in each state over time **while considering varying masking compliance situations**:

$$
\dot{S_v} = -\beta_1(1-MC)S_v(I_{a,v} + TFN_a + TISO_a^-)-\beta_2(1-MC)S_v(I_{s,v}+TFN_s+TISO_s^-)
$$

$$
\dot{S_n} = -\beta_3(1-MC)S_n(I_{a,n} + TFN_a + TISO_a^-)-\beta_4(1-MC)S_n(I_{s,n}+TFN_s+TISO_s^-)
$$

$$
\dot{I_{a, v}}= (1-p_0) \times [\beta_1(1-MC)S_v(I_{a,v}+TFN_a+TISO_a^-)+\beta_2(1-MC)S_v(I_{s,v}+TFN_s+TISO_s^-)]-T_{pcr} \times I_{a,v}-T{rap} \times I_{a,v} -\gamma_aI_{a,v}
$$

$$
\dot{I_{a, n}}= (1-p_0) \times [\beta_3(1-MC)S_n(I_{a,n}+TFN_a+TISO_a^-)+\beta_4(1-MC)S_n(I_{s,n}+TFN_s+TISO_s^-)]-T_{pcr} \times I_{a,n}-T{rap} \times I_{a,n} -\gamma_aI_{a,n}
$$


$$
\dot{I_{s, v}} = p_0 \times [\beta_1(1-MC)S_v(I_{a,v}+TFN_a+TISO_a^-)+\beta_2(1-MC)S_v(I_{s,v}+TFN_s+TISO_s^-)] − T_{pcr} × I_{s,v} − T_{rap} × I_{s,v} − γ_sI_{s,v}
$$
$$
\dot{I_{s, v}} = p_0 \times [\beta_3(1-MC)S_n(I_{a,n}+TFN_a+TISO_a^-)+\beta_4(1-MC)S_n(I_{s,n}+TFN_s+TISO_s^-)] − T_{pcr} × I_{s,n} − T_{rap} × I_{s,n} − γ_sI_{s,n}
$$


$$
\dot{TFN_a} = [T_{pcr} × FN_{pcr_a} × (I_{a,v} + I_{a,n})] + [T_{rap} × FN_{rap_a} × (I_{a,v} + I_{a,n})] − γ_a × TFN_a
$$

$$
\dot{TFN_s} = [T_{pcr} × FN_{pcr_s} × (I_{s,v} + I_{s,n})]+ [T_{rap} × FN_{rap_s} × (I_{s,v} + I_{s,n})] − γ_s × TFN_s
$$

$$
\dot{TISO^+_a} =C_a × [T_{pcr} × FN_{pcr_a} × (I_{a,v} + I_{a,n}) + T_{rap} × FN_{rap_a} × (I_{a,v} + I_{a,n})] − γ_a × TISO^+_a
$$

$$
\dot{TISO^+_s} =C_s × [T_{pcr} × FN_{pcr_s} × (I_{s,v} + I_{s,n}) + T_{rap} × FN_{rap_s} × (I_{s,v} + I_{s,n})] − γ_s × TISO^+_s
$$

$$
\dot{TISO^−_a} =(1 − C_a) × [T_{pcr} × FN_{pcr_a} × (I_{a,v} + I_{a,n}) + T_{rap} × FN_{rap_a} × (I_{a,v} + I_{a,n})] − γ_a × TISO^−_a
$$

$$
\dot{TISO^−_s} =(1 − C_s) × [T_{pcr} × FN_{pcr_s} × (I_{s,v} + I_{s,n}) + T_{rap} × FN_{rap_s} × (I_{s,v} + I_{s,n})] − γ_s × TISO^−_s
$$
$$
\dot{RC} = \gamma × [TISO_a^+ + TISO_s^+ + TISO_a^- + TISO_s^-]
$$

$$
\dot{RU} = \gamma × [(I_{a,v} + I_{a,n}) + (I_{s,v} + I_{s,n}) + TFN_a + TFN_s]
$$


# Code for the Model

## Downloading the Data from the GDPH Website 

The following chunk of code is used to download the most recent county case data from the GDPH website. Because the data from the GDPH website downloads as a zip file, a temporary file must first be created (line 139). We can then download the data from a specified URL (GDPH website) to this temporary file (line 140). The file is then unzipped and read into R using the read.csv() function and the unz() function (line 141). It is important to note that we only want to use the data from the "county_cases.csv" file which is located within the downloaded zip file (which is why we need to specify this specific file when using the unz() function). We then unlink the temp file (line 142). 

Once the data from the "county_cases.csv" file is read into R, we only want to consider certain columns of data within this file. The columns of importance are county_name, cases, population, and X14.day.cases. Lines 147 - 157 removes the unused columns and stores it in a new variable called "county_data". This variable will serve as the starting point for creating the initial states for each county and is used/seen multiple times throughout the code. There are also 2 rows of data that are not associated with a particular county, specified as Non-GA Resident/Unknown State (row 108) and Unknown (row 146) which is why we must remove these two rows from our stored variable (line 158). Additionally, we realize that the number of cases seen on a two-week period are known to be under-reported by a factor between 3.4 to 4.7. For this reason, we reset the "X14.day.cases" variable to the number of cases multiplied by a value between 3.4 - 4.7 chosen at random. The randomness is accounted for by the "runif" function. The ceiling of this value is then taken to ensure a whole number of cases as opposed to fractional cases. Line 158 attaches the column names to the variable so we can refer to them directly (cases as opposed to county_data$cases). 

```{r}
# Download data from GDPH website
temp_file <- tempfile()
download.file("https://ga-covid19.ondemand.sas.com/docs/ga_covid_data.zip", temp_file)
data <- read.csv(unz(temp_file, "county_cases.csv"))
unlink(temp_file)
# Remove unused columns
county_data <- subset(data, select = -c(county_id, 
                                 State.FIPS.code,
                                 County.FIPS.code,
                                 confirmed_case_hospitalization,
                                 antigen_case_hospitalization,
                                 deaths,
                                 case.rate,
                                 death.rate,
                                 X14.day.case.rate,
                                 antigen_cases,
                                 probable_deaths))
county_data <- county_data[-c(108, 146),]
# Account for 1 in 4 cases being reported to DPH
county_data$X14.day.cases <- ceiling(county_data$X14.day.cases * runif(1, min = 3.4, max = 4.7))
attach(county_data)
```

##  Creating a Dictionary of All Counties

The following block of code creates a dictionary called "counties" which stores each of the county names as the keys and a number 1 - 159 as the values. 

[KYLE WRITE ABOUT PURPOSE OF THE COUNITES DICTIONARY]

```{r}
library(hash)

# Hard coded all counties in Georgia
counties <- hash(
                  keys=c(
                   "Appling", "Atkinson", "Bacon", "Baker", "Baldwin", "Banks", "Barrow", "Bartow",
                   "Ben Hill", "Berrien", "Bibb", "Bleckley", "Brantley", "Brooks", "Bryan", "Bulloch",
                   "Burke", "Butts", "Calhoun", "Camden", "Candler", "Carroll", "Catoosa", "Charlton",
                   "Chatham", "Chattahoochee", "Chattooga", "Cherokee", "Clarke", "Clay", "Clayton",
                   "Clinch", "Cobb", "Coffee", "Colquitt", "Columbia", "Cook", "Coweta", "Crawford", "Crisp",
                   "Dade", "Dawson", "DeKalb", "Decatur", "Dodge", "Dooly", "Dougherty", "Douglas", "Early",
                   "Echols", "Effingham", "Elbert", "Emanuel", "Evans", "Fannin", "Fayette", "Floyd",
                   "Forsyth", "Franklin", "Fulton", "Gilmer", "Glascock", "Glynn", "Gordon", "Grady",
                   "Greene", "Gwinnett", "Habersham", "Hall", "Hancock", "Haralson", "Harris", "Hart",
                   "Heard", "Henry", "Houston", "Irwin", "Jackson", "Jasper", "Jeff Davis", "Jefferson",
                   "Jenkins", "Johnson", "Jones", "Lamar", "Lanier", "Laurens", "Lee", "Liberty", "Lincoln",
                   "Long", "Lowndes", "Lumpkin", "Macon", "Madison", "Marion", "McDuffie", "McIntosh", 
                   "Meriwether", "Miller", "Mitchell", "Monroe", "Montgomery", "Morgan", "Murray", 
                   "Muscogee", "Newton", "Oconee", "Oglethorpe", "Paulding", "Peach", "Pickens", "Pierce", 
                   "Pike", "Polk", "Pulaski", "Putnam", "Quitman", "Rabun", "Randolph", "Richmond", 
                   "Rockdale", "Schley", "Screven", "Seminole", "Spalding", "Stephens", "Stewart", "Sumter",
                   "Talbot", "Taliaferro", "Tattnall", "Taylor", "Telfair", "Terrell", "Thomas", "Tift", 
                   "Toombs", "Towns", "Treutlen", "Troup", "Turner", "Twiggs", "Union", "Upson", "Walker",
                   "Walton", "Ware", "Warren", "Washington", "Wayne", "Webster", "Wheeler", "White", 
                   "Whitfield", "Wilcox", "Wilkes", "Wilkinson", "Worth"
                  ),
                  values=1:159
                )
```

## A Function to Store User Inputted Data for a Specific School 

The following block of code creates a function that can be called for a specific school. The input parameters of the function align with the values that a decision-maker is able to input into the simulation, such parameters are defined as follows:

**county (string):** county that user wants to view information for

**days (integer):** number of days that the user wants to run the simulation for

**masking (decimal / numeric):** the proportion of the school population that is wearing masks (0 - 1 with 0.25 intervals)

**student_pop (integer):** the total number of students attending school in-person

**faculty_pop (integer):** the total number of faculty and staff attending school in-person

**student_vax (decimal):** the proportion of the student population that are fully vaccinated 

**faculty_vax (decimal):** the proportion of the faculty/staff population that are fully vaccinated

**testing (decimal):** the proportion of the school population that are regularly participating in surveillance testing 

**pcr (boolean):** a true/false value that specifies what type of surveillance testing a school is participating in (TRUE if PCR testing, FALSE if Rapid Antigen Testing)

Ultimately, this function is called on the back-end to store the values in a dictionary which are inputted by the user on the front-end interface. We can see a call to this function in lines ____ - ____, which allows to obtain the predicted number of cases based on the user's preferences. 

```{r}
# COLIN: this function can be called with all of the user inputted data and returns a dictionary for that school
# Use this function to get county hash with user inputted data (pcr should be a boolean true if pcr selected, false otherwise)
generate_school <- function(county, days, masking, student_pop, faculty_pop, student_vax, faculty_vax, testing, pcr) {
  school <- hash()
  school["county"]           <- county
  school["days"]             <- days
  school["masking"]          <- masking * (1/6)
  school["student_pop"]      <- student_pop
  school["faculty_pop"]      <- faculty_pop
  school["student_vax"]      <- student_vax
  school["faculty_vax"]      <- faculty_vax
  school["testing"]          <- testing
  school["pcr"]              <- pcr
  return(school)
}
```

## Set of Functions to Determine the Initial States for each County

The following set of functions are used to determine the initial states for each county using the data obtained from the "county_cases.csv" file from the GDPH website and stored in the "county_data" variable defined previously. 

### initial_susceptibility

This function determines the proportion of the population that starts out in the susceptible state. It is important to note that at this stage, the susceptible state has not yet been split into the susceptible & vaccinated vs. susceptible & not vaccinated state. The function takes in a data set as the parameter (in our case, it will always be the "county_data" variable, but this will always have to be specified when being called). The equation to determine initial susceptibility takes the total population of a county, subtracts the number of total cases the county has experienced (as they have technically been infected and recovered already), and divides by the total county population to get the proportion. If the data passed into this function were to change their header names, modifications to this function would need to occur in order to reflect these changes. For example, if the data file changes the column header "population" to "county_population", the function's equation would need to change to: result <- (county_data\$county_population - county_data\$cases) / county_data\$county_population.

### initial_infected_symptomatic

This function determines the proportion of the population that starts out in the infected & symptomatic state. It is important to note that at this stage, the infected & symptomatic state has not yet been split into the infected & symptomatic & vaccinated vs. infected & symptomatic & not vaccinated state. The function takes in a data set as the parameter (in our case, it will always be the "county_data" variable, but this will always have to be specified when being called). The equation to determine initial infected & symptomatic takes the number of cases in the past 14 days (which are the people currently infected), divides by the total county population to get the proportion of the population, and then multiplies by the proportion of cases that are symptomatic (p0, which we have determined to be 0.7). If the data passed into this function were to change their header names, modifications to this function would need to occur in order to reflect these changes. For example, if the data file changes the column header "X14.day.cases" to "fourteen.day.cases", the function's equation would need to change to: result <- ((county_data\$fourteen.day.cases) / county_data\$population) * p0. Should the proportion of symptomatic cases change, this can be modified by changing the value of p0 at the top of the code block.

### initial_infected_asymptomatic

This function determines the proportion of the population that starts out in the infected & asymptomatic state. It is important to note that at this stage, the infected & asymptomatic state has not yet been split into the infected & asymptomatic & vaccinated vs. infected & asymptomatic & not vaccinated state. The function takes in a data set as the parameter (in our case, it will always be the "county_data" variable, but this will always have to be specified when being called). The equation to determine initial infected & asymptomatic takes the number of cases in the past 14 days (which are the people currently infected), divides by the total county population to get the proportion of the population, and then multiplies by the proportion of cases that are asymptomatic (1 - p0, which we have determined to be 0.3 because 1 - 0.7 = 0.3). If the data passed into this function were to change their header names, modifications to this function would need to occur in order to reflect these changes. For example, if the data file changes the column header "X14.day.cases" to "fourteen.day.cases", the function's equation would need to change to: result <- ((county_data\$fourteen.day.cases) / county_data\$population) * (1 - p0).

**Note: if the proportion of symptomatic cases changes in the initial_infected_symptomatic equation, the proportion of asymptomatic cases must also change to 1 - [new value] so that they sum to 1.**

### initial_recovered_unknown

This function determines the proportion of the population that starts out in the recovered unknown state, which takes into account the people who have been infected and assumed recovered from the Covid-19 virus. The function takes in a data set as the parameter (in our case, it will always be the "county_data" variable, but this will always have to be specified when being called). The equation to determine initial recovered unknown takes the total number of cases that a county has had, subtracts the number of people that are currently infected (X14.day.cases), and divides by the total county population to get the proportion. If the data passed into this function were to change their header names, modifications to this function would need to occur in order to reflect these changes. For example, if the data file changes the column header "X14.day.cases" to "fourteen.day.cases", the function's equation would need to change to: result <- (county_data\$cases - county_data\$fourteen.day.cases) / county_data\$population.

```{r}
# Functions defining initial states for all counties
# Need to change these functions to not hard-code the proportion of symptomatic vs. asymptomatic 

p0 = 0.7  # proportion of infections that are symptomatic

initial_susceptibility <- function(county_data) {
  result <- (county_data$population - county_data$cases) / county_data$population
  return(result)
}
initial_infected_symptomatic <- function(county_data) {
  result <- ((county_data$X14.day.cases) / county_data$population) * p0
  return(result)
}
initial_infected_asymptomatic <- function(county_data) {
  result <- ((county_data$X14.day.cases) / county_data$population) * (1 - p0)
  return(result)
}
initial_recovered_unknown <- function(county_data) {
  result <- (county_data$cases - county_data$X14.day.cases) / county_data$population
  return(result)
}
```


## Obtaining the Data for the User's Specified County & Using Their Preferences

This block of code is used to obtain all of the user-inputted data, and then uses this data to call on our previously defined function "generate_school()". 

**county (string):** county that user wants to view information for

**days (integer):** number of days that the user wants to run the simulation for

**masking (decimal / numeric):** the proportion of the school population that is wearing masks (0 - 1)

**student_pop (integer):** the total number of students attending school in-person

**faculty_pop (integer):** the total number of faculty and staff attending school in-person

**VR_s (decimal):** the proportion of the student population that are fully vaccinated 

**VR_f (decimal):** the proportion of the faculty/staff population that are fully vaccinated

**testing (decimal):** the proportion of the school population that are regularly participating in surveillance testing 

**pcr (boolean):** a true/false value that specifies what type of surveillance testing a school is participating in (TRUE if PCR testing, FALSE if Rapid Antigen Testing)

In order to scale the percentage of the total population that is vaccinated, while also taking into account the differences in percentage vaccinated between students and faculty/staff, some equations are necessary to apply these changes. First, we must obtain the number of students vaccinated and the number of faculty/staff vaccinated based on the user-inputted values for student population, student vaccination percentage, faculty/staff population, and faculty/staff vaccination percentage. This can be seen in the lines that calculate "students_vaccinated" and "faculty_vaccinated". Then, in order to calculate the total proportion of the total population that has been vaccinated, we have taken the total population (by adding student_pop + faculty_pop) and then obtained the total percent vaccinated in the school setting by taking the following equation:

percent_school_vaccinated = (students_vaccinated + faculty_vaccinated) / total_school_population

These equations will allow us to scale the community data down to the school level while taking into account user inputs and school-specific conditions.

Next, lines 333-343 is where we actually take the community data and scale it to the school level.

**county_data\$S_0 <- initial_susceptibility(county_data)**: calculates the initial proportion of the population for the specified county that starts in the susceptible state, this equation calls on the previously defined function "initial_susceptibility()"

**county_data\$S_0_v <- (county_data\$S_0)*percent_school_vaccinated**: uses the percentage of the school (calculated previously) to split the susceptible state and calculate the percentage of the population for the specified county that starts in the susceptible & vaccinated state

**county_data\$S_0_n <- (county_data\$S_0)*(1 - percent_school_vaccinated)**: uses the percentage of the school (calculated previously) to split the susceptible state and calculate the percentage of the population for the specified county that starts in the susceptible & not vaccinated state (using 1 - percent_school_vaccinated)

**county_data\$I_sv <- 0.5 * initial_infected_symptomatic(county_data)**:  calculates the initial proportion of the population for the specified county that starts in the infected, symptomatic, and vaccinated state; this equation calls on the previously defined function "initial_infected_symptomatic()"; there is a multiplier of 0.5 to split the proportion of total infected & symptomatic into infected, symptomatic, & vaccinated vs. infected, symptomatic, & not vaccinated -- if more information arises on the topic of proportions regarding infected, symptomatic, & vaccinated vs. not vaccinated, this proportion should need to be changed 

**county_data\$I_sn <- 0.5 * initial_infected_symptomatic(county_data)**: calculates the initial proportion of the population for the specified county that starts in the infected, symptomatic, and not vaccinated state; this equation calls on the previously defined function "initial_infected_symptomatic()"; there is a multiplier of 0.5 to split the proportion of total infected & symptomatic into infected, symptomatic, & vaccinated vs. infected, symptomatic, & not vaccinated -- if more information arises on the topic of proportions regarding infected, symptomatic, & vaccinated vs. not vaccinated, this proportion should need to be changed (1 - previous proportion used)

**county_data\$I_av <- 0.5 * initial_infected_asymptomatic(county_data)**: calculates the initial proportion of the population for the specified county that starts in the infected, asymptomatic, and vaccinated state; this equation calls on the previously defined function "initial_infected_asymptomatic()"; there is a multiplier of 0.5 to split the proportion of total infected & asymptomatic into infected, asymptomatic, & vaccinated vs. infected, asymptomatic, & not vaccinated -- if more information arises on the topic of proportions regarding infected, asymptomatic, & vaccinated vs. not vaccinated, this proportion should need to be changed 

**county_data\$I_an <- 0.5 * initial_infected_asymptomatic(county_data)**: calculates the initial proportion of the population for the specified county that starts in the infected, asymptomatic, and vaccinated state; this equation calls on the previously defined function "initial_infected_asymptomatic()"; there is a multiplier of 0.5 to split the proportion of total infected & asymptomatic into infected, asymptomatic, & vaccinated vs. infected, asymptomatic, & not vaccinated -- if more information arises on the topic of proportions regarding infected, asymptomatic, & vaccinated vs. not vaccinated, this proportion should need to be changed 

**county_data\$R_u <- initial_recovered_unknown(county_data)**: calculates the initial proportion of the population for the specified county that starts in the recovered unknown state; this equation calls on the previously defined function "initial_recovered_unknown()"

Because it is essential that the population remains a closed system, and that the model keeps track of all people within a population, it is essential that at all points in the simulation model that the total sum of all the proportions for each state equal 1. The follow line of code is what provides this check. Should this total not equal to 1, this is an indication that an error has occurred somewhere in the data or code and that the simulation model is no longer accurate. 

**county_data\$total <- county_data\$S_0_v + county_data\$S_0_n + county_data\$I_sv + county_data\$I_av + county_data\$I_sn + county_data\$I_an + county_data\$R_u**


**school <- generate_school(toString(county), days, masking, student_pop, faculty_pop, VR_s, VR_f, testing, pcr)**: this line of code calls on the "generate_school()" function and allows for storage of the user's inputted data; toString(county) ensures that the county input by the user is a string. 

**single_county_data <- county_data[values(counties, key=c(county)),]**: this line of code allows us to isolate a single row of data from the "county_data" data frame containing all information from all counties, which in essence allows us to isolate the information for a single, specified county. [KYLE TO EXPLAIN LOGIC OF ISOLATION?]


```{r}
# This is where we obtain all values from the user inputted data and call generate_school(). it should look something like this
# just replace the hard coded values with the values provided by the user
county <- "Fulton"
days <- 14
masking <- 0.5
student_pop <- 500
faculty_pop <- 50
VR_s <- 0
VR_f <- 0
testing <- 0.5
pcr <- TRUE

students_vaccinated <- student_pop * VR_s
faculty_vaccinated <- faculty_pop * VR_f
total_school_population <- student_pop + faculty_pop
percent_school_vaccinated <- (students_vaccinated + faculty_vaccinated) / total_school_population

# Scale county_data for all counties to include initial states for simulation
county_data$S_0 <- initial_susceptibility(county_data)
county_data$S_0_v <- (county_data$S_0)*percent_school_vaccinated
county_data$S_0_n <- (county_data$S_0)*(1 - percent_school_vaccinated)
county_data$I_sv <- 0.5 * initial_infected_symptomatic(county_data)
county_data$I_sn <- 0.5 * initial_infected_symptomatic(county_data)
county_data$I_av <- 0.5 * initial_infected_asymptomatic(county_data)
county_data$I_an <- 0.5 * initial_infected_asymptomatic(county_data)
county_data$R_u <- initial_recovered_unknown(county_data)
county_data$total <- county_data$S_0_v + county_data$S_0_n + county_data$I_sv + county_data$I_av + county_data$I_sn + county_data$I_an + county_data$R_u

school <- generate_school(toString(county), days, masking, student_pop, faculty_pop, VR_s, VR_f, testing, pcr)
single_county_data <- county_data[values(counties, key=c(county)),]
```

## Specifying Initial Built-In Parameters & Defining the Initial State of the System

The following section sets the initial, built-in parameters that the simulation model needs in order to function. The parameters are defined as follows, and can be updated here should more information arise regarding these parameters. It should also be noted that if the simulation model requires calibration, this section is where the calibration would most likely take place.

[KYLE PLEASE DISCUSS THE "RUNIF" LOGIC FOR THE BETA VALUES]

**b_1**: transmission rate due to contact between susceptible vaccinated and infected asymptomatic patient

**b_2**: transmission rate due to contact between susceptible vaccinated and infected symptomatic patient

**b_3**: transmission rate due to contact between susceptible not vaccinated and infected asymptomatic patient

**b_4**: transmission rate due to contact between susceptible not vaccinated and infected symptomatic patient

**gamma**: rate of recovery for an infected individual

**p0**: proportion of infections that are symptomatic

**c_a**: isolation compliance asymptomatic infected + tested patients

**c_s**: isolation compliance symptomatic infected + tested patients

**FNpcr_a**: false negative rate of a PCR test for asymptomatic patients

**FNpcr_s**: false negative rate of a PCR test for symptomatic patients

**FNrap_a**: false negative rate of a rapid test for asymptomatic patients

**FNrap_s**: false negative rate of a rapid test for symptomatic patients

**FPpcr_a**: false positive rate of a PCR test for asymptomatic patients (not seen / used in the code, strictly for informational purposes)

**FPpcr_s**: false positive rate of a PCR test for symptomatic patients (not seen / used in the code, strictly for informational purposes)

**FPrap_a**: false positive rate of a rapid test for asymptomatic patients (not seen / used in the code, strictly for informational purposes)

**FPrap_s**: false positive rate of a rapid test for symptomatic patients (not seen / used in the code, strictly for informational purposes)

**S_0_v = as.numeric(single_county_data[6])**: initial susceptibility of the vaccinated school population; obtains the value for S_0_v from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 6 refers to the column number at which S_0_v is stored in within the "single_county_data" data frame 

**S_0_n = as.numeric(single_county_data[7])**: initial susceptibility of the not vaccinated school population; obtains the value for S_0_n from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 7 refers to the column number at which S_0_n is stored in within the "single_county_data" data frame 

**I_sv = as.numeric(single_county_data[8])**: initial infected, symptomatic, and vaccinated; obtains the value for I_sv from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 8 refers to the column number at which I_sv is stored in within the "single_county_data" data frame 

**I_sn = as.numeric(single_county_data[9])**: initial infected, symptomatic, and not vaccinated; obtains the value for I_sn from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 9 refers to the column number at which I_sn is stored in within the "single_county_data" data frame 

**I_av = as.numeric(single_county_data[10])**: initial infected, asymptomatic, and vaccinated; obtains the value for I_av from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 10 refers to the column number at which I_av is stored in within the "single_county_data" data frame 

**I_an = as.numeric(single_county_data[11])**: initial infected, asymptomatic, and not vaccinated; obtains the value for I_an from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 11 refers to the column number at which I_an is stored in within the "single_county_data" data frame 

**R_u = as.numeric(single_county_data[12])**: initial recovered unknown; obtains the value for R_u from the "single_county_data" variable defined earlier which contains the initial states for the user's specified county; 12 refers to the column number at which R_u is stored in within the "single_county_data" data frame 

**R_c**: initial recovered confirmed; simulation always starts out with 0 for this state [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**TFN_a**: initial population with a false negative and asymptomatic; starts with 0 because [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**TFN_s**: initial population with a false negative and symptomatic; starts with 0 because [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**TISO_an**: initial population tested with infection, not in isolation, asymptomatic; starts with 0 because [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**TISO_ap**: initial population tested with infection, in isolation, asymptomatic; starts with 0 because [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**TISO_sn**: initial population tested with infection, not in isolation, symptomatic; starts with 0 because [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**TISO_sp**: initial population tested with infection, in isolation, symptomatic; starts with 0 because [TALK TO KYLE FOR HELP WITH WORDING FOR REASONING]

**n**: the total population of the school calculated by summing the value of the student population and the value of the faculty/staff population as specified by the user

**days**: the number of days that the user wants to run the simulation for

**semester**: a sequence variable that takes the "days" variable as an input and will be used later on in the "run_simulation" function (it is important this variable is of a sequence type as the function needs to take a sequence variable type in as opposed to an integer)

**The T_pcr & T_rap parameters**: there is an "if-else" block of code that sets the values for T_pcr and T_rap. Because we are operating under the assumption that a school is only using one type of testing, if the user enters that their school is participating in PCR testing, then the the value of T_pcr is set to the proportion of the population participating in PCR testing and the value of T_rap is set to 0. And if the user enters that their school is participating in Rapid Antigen Testing, then the value of T_rap is set to the proportion of the population participating in Rapid Antigen Testing and the value of T_pcr is set to 0. 

Once these built-in parameters have been specified, we can define the variables that will later be used in the differential equations, simulation model seen later on. It is important to note that the simulation model takes in a set of lists to help define the initial states of the system as well as specified parameters. For that reason, we obtain the following variables which sets the parameters that the model will take in to the values we have just defined for them:

* testing

* no_testing

* initial_state

The reason why we have a "testing" variable and a "no_testing" variable is to mimic the model created in a joint effort by Georgia Tech, NC State University, and DPH which assumed that testing was occurring on a weekly basis on the first day of the week, and for the remaining 6 days of the week, no testing was occurring. This is why you can see that when setting the parameters in the "testing" variable, the values for T_pcr and T_rap are set equal to the user-defined value, while in the "no_testing" variable, those variables are automatically set to 0 (other than this, the two variables are identical). 

It should be mentioned as well that the "testing" and "no_testing" variables set the parameters, while the "initial_state" variable sets the initial state values for the simulation for the user's specified county. 

```{r}
# Initial built-in parameters
# The 40 found in the beta initialization signifies the simulation will run 40 times. If you would like to run it for a different number of iterations, change the values here.
b_1 = runif(40, 0.051, 0.068)          # transmission rate due to contact between susceptible vaccinated and infected asymptomatic patient
b_2 = runif(40, 0.102, 0.136)          # transmission rate due to contact between susceptible vaccinated and infected symptomatic patient
b_3 = runif(40, 0.150, 0.200)          # transmission rate due to contact between susceptible not vaccinated and infected asymptomatic patient
b_4 = runif(40, 0.300, 0.400)          # transmission rate due to contact between susceptible not vaccinated and infected symptomatic patient
gamma = 0.1        # rate of recovery for an infected individual
p0 = 0.7           # proportion of infections that are symptomatic
c_a = 1            # isolation compliance asymptomatic infected + tested patients
c_s = 1            # isolation compliance symptomatic infected + tested patients
FNpcr_a = 0.149    # false negative rate of a PCR test for asymptomatic patients
FNpcr_s = 0.149    # false negative rate of a PCR test for symptomatic patients
FNrap_a = 0.37     # false negative rate of a rapid test for asymptomatic patients
FNrap_s = 0.37     # false negative rate of a rapid test for symptomatic patients
FPpcr_a = 0.05     # false positive rate of a PCR test for asymptomatic patients
FPpcr_s = 0.05     # false positive rate of a PCR test for symptomatic patients
FPrap_a = 0.10     # false positive rate of a rapid test for asymptomatic patients
FPrap_s = 0.10     # false positive rate of a rapid test for symptomatic patients
# Initial susceptibility values
S_0_v = as.numeric(single_county_data[6])    # initial susceptibility of the vaccinated school population
S_0_n = as.numeric(single_county_data[7])    # initial susceptibility of the not vaccinated school population
# Calculations for the initial infected
I_sv = as.numeric(single_county_data[8])     # initial infected, symptomatic, and vaccinated
I_sn = as.numeric(single_county_data[9])     # initial infected, symptomatic, and not vaccinated
I_av = as.numeric(single_county_data[10])    # initial infected, asymptomatic, and vaccinated
I_an = as.numeric(single_county_data[11])    # initial infected, asymptomatic, and not vaccinated
# Recovered states
R_u = as.numeric(single_county_data[12])     # initial recovered unknown
R_c = 0.0                                    # initial recovered confirmed
# Initial test values (no tests administered)
TFN_a = 0       # initial population with a false negative and asymptomatic
TFN_s = 0       # initial population with a false negative and symptomatic 
TISO_an = 0     # initial population tested with infection, not in isolation, asymptomatic 
TISO_ap = 0     # initial population tested with infection, in isolation, asymptomatic 
TISO_sn = 0     # initial population tested with infection, not in isolation, symptomatic
TISO_sp = 0     # initial population tested with infection, in isolation, symptomatic
n = values(school, key=c("student_pop")) + values(school, key=c("faculty_pop"))       # school population
# Days in simulation
days <- values(school, key=c("days"))
# Sequence for semester
semester <- seq(1, days, by=1)
# Here we determine if we are pcr testing based on user input, if we are, assign pcr testing percentage to user inputted testing percentage. else, assign to rapid testing percentage
if (values(school, key=c("pcr"))) {
  T_pcr <- values(school, key=c("testing"))
  T_rap <- 0
} else {
  T_pcr <- 0
  T_rap <- values(school, key=c("testing"))
}
# Initial built in parameters for testing and no testing days
testing <- c(b_1 = b_1[1], b_2 = b_2[1], b_3 = b_3[1], b_4 = b_4[1], p0 = p0, c_a = c_a, c_s = c_s, MC = values(school, key=c("masking")), T_pcr = T_pcr, T_rap = T_rap, gamma = gamma, FNpcr_a = FNpcr_a, FNpcr_s = FNpcr_s, FNrap_a = FNrap_a, FNrap_s = FNrap_s)
no_testing <- c(b_1 = b_1[1], b_2 = b_2[1], b_3 = b_3[1], b_4 = b_4[1], p0 = p0, c_a = c_a, c_s = c_s, MC = values(school, key=c("masking")), T_pcr = 0, T_rap = 0, gamma = gamma, FNpcr_a = FNpcr_a, FNpcr_s = FNpcr_s, FNrap_a = FNrap_a, FNrap_s = FNrap_s)
# Initial state of the system
initial_state <- c(S_0_v = S_0_v, S_0_n = S_0_n, I_av = I_av, I_an = I_an, I_sv = I_sv, I_sn = I_sn, TFN_a = TFN_a, TFN_s = TFN_s, TISO_an = TISO_an, TISO_sn = TISO_sn, TISO_ap = TISO_ap, TISO_sp = TISO_sp, RC = R_c, RU = R_u)
```

## Creating Functions to Define the State Transition Differential Equations

The following block of code translates the state transition differential equations listed previously into callable functions within the code. For this reason, if any of the equations are modified in any way, these changes would be need to be reflected in the following section to ensure that they are appropriate reflected in the simulation and results. 

Each of the functions has a set of parameters that they can take in as inputs, and then they use these inputs to calculate and return the respective values. For instance, the initial susceptible & vaccinated state equation (S_dot_v) utilizes the transmission rate due to contact between susceptible vaccinated and infected asymptomatic patient (b_1), the proportion of the school population that is wearing masks (MC), the initial susceptibility of the vaccinated school population (S_0_v), initial infected, asymptomatic, and vaccinated (I_av), initial population with a false negative and asymptomatic (TFN_a), initial population tested with infection, not in isolation, asymptomatic (TISO_an),  transmission rate due to contact between susceptible vaccinated and infected symptomatic patient (b_2), initial infected, symptomatic, and vaccinated (I_sv), initial population with a false negative and symptomatic (TFN_s), and initial population tested with infection, not in isolation, symptomatic (TISO_sn). The "S_dot_v" can then use these values to calculate, predict, and return the result for the susceptible and vaccinated state for the following day. This is important because the value that is return for the following day is used as the initial state for predicted the day after the following day (and so on for the specified duration of the simulation model).


```{r}
# State transition differential equation definitions
S_dot_v <- function(b_1, MC, S_0_v, I_av, TFN_a, TISO_an, b_2, I_sv, TFN_s, TISO_sn) {
  result <- (-b_1 * (1 - MC) * S_0_v * (I_av + TFN_a + TISO_an)) - (b_2 * (1 - MC) * S_0_v * (I_sv + TFN_s + TISO_sn))
  return(result)
}
S_dot_n <- function(b_3, MC, S_0_n, I_an, TFN_a, TISO_an, b_4, I_sn, TFN_s, TISO_sn) {
  result <- (-b_3 * (1 - MC) * S_0_n * (I_an + TFN_a + TISO_an)) - (b_4 * (1 - MC) * S_0_n * (I_sn + TFN_s + TISO_sn))
  return(result)
}
I_av_dot <- function(p0, b_1, MC, S_0_v, I_av, TFN_a, TISO_an, b_2, I_sv, TFN_s, TISO_sn, T_pcr, T_rap, gamma) {
  result <- (1 - p0) * ((b_1 * (1 - MC) * S_0_v * (I_av + TFN_a + TISO_an)) + (b_2 * (1 - MC) * S_0_v * (I_sv + TFN_s + TISO_sn))) - (T_pcr * I_av) - (T_rap * I_av) - (gamma * I_av)
  return(result)
}
I_an_dot <- function(p0, b_3, MC, S_0_n, I_an, TFN_a, TISO_an, b_4, I_sn, TFN_s, TISO_sn, T_pcr, T_rap, gamma) {
  result <- (1 - p0) * ((b_3 * (1 - MC) * S_0_n * (I_an + TFN_a + TISO_an)) + (b_4 * (1 - MC) * S_0_n * (I_sn + TFN_s + TISO_sn))) - (T_pcr * I_an) - (T_rap * I_an) - (gamma * I_an)
  return(result)
}
I_sv_dot <- function(p0, b_1, MC, S_0_v, I_av, TFN_a, TISO_an, b_2, I_sv, TFN_s, TISO_sn, T_pcr, T_rap, gamma) {
  result <- p0 * ((b_1 * (1 - MC) * S_0_v * (I_av + TFN_a + TISO_an)) + (b_2 * (1 - MC) * S_0_v * (I_sv + TFN_s + TISO_sn))) - (T_pcr * I_sv) - (T_rap * I_sv) - (gamma * I_sv)
  return(result)
}
I_sn_dot <- function(p0, b_3, MC, S_0_n, I_an, TFN_a, TISO_an, b_4, I_sn, TFN_s, TISO_sn, T_pcr, T_rap, gamma) {
  result <- p0 * ((b_3 * (1 - MC) * S_0_n * (I_an + TFN_a + TISO_an)) + (b_4 * (1 - MC) * S_0_n * (I_sn + TFN_s + TISO_sn))) - (T_pcr * I_sn) - (T_rap * I_sn) - (gamma * I_sn)
  return(result)
}
TFN_a_dot <- function(T_pcr, FNpcr_a, I_av, I_an, T_rap, FNrap_a, gamma, TFN_a) {
  result <- (T_pcr * FNpcr_a * (I_av + I_an)) + (T_rap * FNrap_a * (I_av + I_an)) - (gamma * TFN_a)
  return(result)
}
TFN_s_dot <- function(T_pcr, FNpcr_s, I_sv, I_sn, T_rap, FNrap_s, gamma, TFN_s) {
  result <- (T_pcr * FNpcr_s * (I_sv + I_sn)) + (T_rap * FNrap_s * (I_sv + I_sn)) - (gamma * TFN_s)
  return(result)
}
TISO_ap_dot <- function(c_a, T_pcr, FNpcr_a, I_av, I_an, T_rap, FNrap_a, gamma, TISO_ap) {
  result <- c_a * ((T_pcr * (1 -FNpcr_a) * (I_av + I_an)) + (T_rap * (1 - FNrap_a) * (I_av + I_an))) - (gamma * TISO_ap)
  return(result)
}
TISO_sp_dot <- function(c_s, T_pcr, FNpcr_s, I_sv, I_sn, T_rap, FNrap_s, gamma, TISO_sp) {
  result <- c_s * ((T_pcr * (1 - FNpcr_s) * (I_sv + I_sn)) + (T_rap * (1 - FNrap_s) * (I_sv + I_sn))) - (gamma * TISO_sp)
  return(result)
}
TISO_an_dot <- function(c_a, T_pcr, FNpcr_a, I_av, I_an, T_rap, FNrap_a, gamma, TISO_an) {
  result <- (1 - c_a) * ((T_pcr * (1 - FNpcr_a) * (I_av + I_an)) + (T_rap * (1 - FNrap_a) * (I_av + I_an))) - (gamma * TISO_an)
  return(result)
}
TISO_sn_dot <- function(c_s, T_pcr, FNpcr_s, I_sv, I_sn, T_rap, FNrap_s, gamma, TISO_sn) {
  result <- (1 - c_s) * ((T_pcr * (1 - FNpcr_s) * (I_sv + I_sn)) + (T_rap * (1 - FNrap_s) * (I_sv + I_sn))) - (gamma * TISO_sn)
  return(result)
}
RC_dot <- function(gamma, TISO_ap, TISO_sp, TISO_an, TISO_sn) {
  result <- gamma * (TISO_ap + TISO_sp + TISO_an + TISO_sn)
  return(result)
}
RU_dot <- function(gamma, I_av, I_an, I_sv, I_sn, TFN_a, TFN_s) {
  result <- gamma * ((I_av + I_an) + (I_sv + I_sn) + TFN_a + TFN_s)
  return(result)
}
```

## The Simulation Model

The following section of code is what enables the simulation model to function and run as intended. First, we must let R know that we will be using the packages "deSolve", "scatterplot3d", and "lubridate", and this can be seen by calling "library(-package-)". 

Lines ____ - ____ defines the function which allows the differential equations to update day over day. The function takes in 3 parameters as inputs:

1. **t**: the specified time period (in days) that the user wants to run the simulation for

2. **state**: a list containing the initial state values of the system 

3. **parameters**: a list containing the values of the necessary parameters used in the differential equations functions

Using these specified inputs, the "differentials" function then calculates the predicted values for each state for the following day by calling on the previously defined state equation functions and using the initial state values and parameters passed into the function. More formally, the variables being defined within this function that call on the previously defined differential equation functions refer to the rate of change of the proportion of the population that are leaving or entering into one of the other states. The function then returns the set of predicted values for each state as a list for the following day. This is important because in the second part of this code block, the predicted state values returned for the following day will be used as the initial state values for predicted the 3rd day (and so on). This is why the first line of the function is writtend "with(as.list(c(state, parameters)))" and why the function returns a list as well, written as "return(list(c(-predicted state values-)))". It should also be noted, that if any of the state equations change, they will also need to be updated in this section of the code. For instance, if additional parameters or values are added to the S_dot equation, these changes will need to be reflected here to obtain the true, predicted value of dS_v. 

The second function in this block of code is the "run_simulation" function, which takes in 4 parameters as inputs:

1. **state**: a list containing the initial state values of the system

2. **testing**: a list containing the values of the necessary parameters used in the differential equation functions *on days in which testing occurs*

3. **no_testing**: a list containing the values of the necessary parameters used in the differential equation functions *on days in which testing does NOT occur*
 
4. **semester**: the length of time in days that the user wants to run the simulation for (this variable is defined previously as a sequence based on the number of days that user has specified, it is important to note that this variable is a sequence type variable and NOT an integer)

This function starts off by instantiating a "states" list that the list of values for each predicted day are added to as the simulation runs so that we are able to view the changes in states day over day. The function then iterates over the days of the specified duration (in this case, semester) and creates a sequence for each day. Creating a sequence for each day is what allows the simulation to use the differential equations to use the initial states to predict the following day's state values. Because of the assumption that testing only occurs once per week, the function then includes and "if-else"  block. This "if-else" statement says that if the t-th day is divisible without a remainder (or rather, the t-th day is a multiple of 7), then the parameters used should be those specified by the "testing" variable, and otherwise (days 1-6), the parameters used in the simulation for that day should be those specified by the "no_testing" variable. In this case, the only way in which the "testing" and "no_testing" variable differ is in that of the T_pcr or T_rap parameters. The "testing" variable sets the T_pcr or T_rap variable to percentage of the population participating in regular testing that the user specifies, while the "no_testing" variable has these values automatically defaulted to 0. Following the "if-then" block, the "run_simulation" function re-sets the initial "state" parameter to the results returned by the "ode" function, which is a differential equation helper function that utilizes initial "state" variable passed into the "run_simulation" function, the "day" sequence variable that was instantiated previously, the "differentials" function that we mentioned previously, and the "parameters" variable which we have set in the "if-else" block based on whether or not the day is a "testing" or "no_testing" day. Re-instantiating the "state" variable allows the following day to use the predicted values as the initial values for that day. 

Furthermore, this ode (refering to Ordinary Differential Equations) solves ordinary differential equations in R and contains two integration methods. This ode function is essentially how the model is solved as it returns an object of class deSolve with a matrix that contains the values of the state variables at the requested output times. The reason behind having the indexed "[2, c(2:15)]" at the end of this line of code is to capture only the predicted values for the 14 states as a list. 

Lastly, the predicted values for each state for the following day are added to the "states" list so that we are able to track the differences / state changes day over day and store them in a single variable. The "run_simulation" function then returns this "states" variable so that we are actually able to view the results. It is important to note that this function returns the final values (which are proportions of the population) for all 14 states day over day for the specified duration. This means that simply running this "run_simulation" function will not output the number of predicted cases. Please refer to the next section of this manual "Calculating the Number of Cases per Day, Cumulative Cases, and Graphing the Results" in order to see how the changes in the state values day over day are translated to the predicted number of cases. 

[KYLE PLEASE UPDATE THIS SECTION TO DISCUSS THE MC.MASKING INPUT FOR THE SUSCEPTIBLE/INFECTED STATES & DISCUSS THE 2 FOLLOWING FUNCTIONS NECESSARY FOR INTERNAL USE]

```{r, results='hide'}
library(deSolve)
library(scatterplot3d)
library(lubridate)
```

```{r}
# Define generic differential update function
differentials <- function(t, state, parameters) {
  with(as.list(c(state, parameters)), {
    dS_v <- S_dot_v(b_1, MC.masking, S_0_v, I_av, TFN_a, TISO_an, b_2, I_sv, TFN_s, TISO_sn)
    dS_n <- S_dot_n(b_3, MC.masking, S_0_n, I_an, TFN_a, TISO_an, b_4, I_sn, TFN_s, TISO_sn)
    dI_av <- I_av_dot(p0, b_1, MC.masking, S_0_v, I_av, TFN_a, TISO_an, b_2, I_sv, TFN_s, TISO_sn, T_pcr, T_rap, gamma)
    dI_an <- I_an_dot(p0, b_3, MC.masking, S_0_n, I_an, TFN_a, TISO_an, b_4, I_sn, TFN_s, TISO_sn, T_pcr, T_rap, gamma)
    dI_sv <- I_sv_dot(p0, b_1, MC.masking, S_0_v, I_av, TFN_a, TISO_an, b_2, I_sv, TFN_s, TISO_sn, T_pcr, T_rap, gamma)
    dI_sn <- I_sn_dot(p0, b_3, MC.masking, S_0_n, I_an, TFN_a, TISO_an, b_4, I_sn, TFN_s, TISO_sn, T_pcr, T_rap, gamma)
    dTFN_a <- TFN_a_dot(T_pcr, FNpcr_a, I_av, I_an, T_rap, FNrap_a, gamma, TFN_a)
    dTFN_s <- TFN_s_dot(T_pcr, FNpcr_s, I_sv, I_sn, T_rap, FNrap_s, gamma, TFN_s)
    dTISO_ap <- TISO_ap_dot(c_a, T_pcr, FNpcr_a, I_av, I_an, T_rap, FNrap_a, gamma, TISO_ap)
    dTISO_sp <- TISO_sp_dot(c_s, T_pcr, FNpcr_s, I_sv, I_sn, T_rap, FNrap_s, gamma, TISO_sp)
    dTISO_an <- TISO_an_dot(c_a, T_pcr, FNpcr_a, I_av, I_an, T_rap, FNrap_a, gamma, TISO_an)
    dTISO_sn <- TISO_sn_dot(c_s, T_pcr, FNpcr_s, I_sv, I_sn, T_rap, FNrap_s, gamma, TISO_sn)
    dRC <- RC_dot(gamma, TISO_ap, TISO_sp, TISO_an, TISO_sn)
    dRU <- RU_dot(gamma, I_av, I_an, I_sv, I_sn, TFN_a, TFN_s)
    return(list(c(dS_v, dS_n, dI_av, dI_an, dI_sv, dI_sn, dTFN_a, dTFN_s, dTISO_an, dTISO_sn, dTISO_ap, dTISO_sp, dRC, dRU)))
  })
}
run_simulation <- function(state, testing, no_testing, semester) {
  states <- list()
  for (t in semester) {
    day <- seq(t - 1, t, by=1)
    if (t %% 7 == 0) {
      parameters <- testing
    } else {
      parameters <- no_testing
    }
    state <- ode(y = state, times = day, func = differentials, parms = parameters)[2,c(2:15)]
    states[[length(states) + 1]] <- state
  }
  return(states)
}

# Helper function for internal use
update_parms <- function(i, testing, no_testing) {
  testing["b_1"] <- b_1[i]
  testing["b_2"] <- b_2[i]
  testing["b_3"] <- b_3[i]
  testing["b_4"] <- b_4[i]
  no_testing["b_1"] <- b_1[i]
  no_testing["b_2"] <- b_2[i]
  no_testing["b_3"] <- b_3[i]
  no_testing["b_4"] <- b_4[i]
  return(c(testing, no_testing))
}
# Use this function to run simulation for j number of times
run_simulation_repeated <- function(j, state, testing, no_testing, semester) {
  all_states <- list()
  for (i in 1:j) {
    parms <- update_parms(i, testing, no_testing)
    solution <- run_simulation(state, parms[1:15], parms[16:31], semester)
    all_states[[length(all_states) + 1]] <- solution
  }
  return(all_states)
}
```

## Calculating the Number of Cases per Day, Cumulative Cases, and Graphing the Results

**[KYLE NEEDS TO WRITE THIS SECTION]**

The following code block is primarily used for statistical analysis of the results from running the simulation $i$ number of times. By default, $i = 40$. To change the total number of iterations, please modify the $40$ found in the function call on the last line of the previous code block.
```{r}
library(plotrix)
# Function to determine number of cases for each day. Returns list of length days where each element is the cases for that day
calculate_cases <- function(states) {
  cases_per_day <- list()
  cases_per_day[1] <- 0
  for (i in 2:days) {
    previous_state <- states[[i - 1]]
    current_state <- states[[i]]
    
    current_susceptibility <- as.numeric(current_state["S_0_v"] + current_state["S_0_n"])
    infection_attack_rate <- as.numeric((previous_state["S_0_v"] + previous_state["S_0_n"])) - current_susceptibility
    decimal_of_IAR <- (infection_attack_rate * n) - floor(infection_attack_rate * n)
    if (decimal_of_IAR >= 0.5) {
      cases_per_day[i] <- ceiling(infection_attack_rate * n)
    } else {
      cases_per_day[i] <- floor(infection_attack_rate * n)
    }
    cases_per_day[i] <- as.numeric(cases_per_day[i])
  }
  return(cases_per_day)
}
# Function to determine cumulative cases over the simulation duration. Returns list of length days where each element is the total cases since the start of the simulation
calculate_cumulative_cases <- function(cases_per_day) {
  cumulative_cases <- list()
  running_total <- 0
  for (i in 1:length(cases_per_day)) {
    cumulative_cases[i] <- running_total
    running_total <- running_total + as.numeric(cases_per_day[i])
  }
  return(cumulative_cases)
}
# Use this function to get cases per day for multiple simulation runs
calculate_cases_multiple_simulations <- function(j, results) {
  total_cases <- list()
  for (i in 1:j) {
    cases_per_day <- calculate_cases(results[[i]])
    total_cases[[length(total_cases) + 1]] <- cases_per_day
  }
  return(total_cases)
}
# Function converts total_cases to a list of list. Outer list is number of cases for day i within each simulation. Inner list is of length number of simulations
reorganize_total_cases <- function(n, total_cases) {
  reorganized_cases <- list()
  for (j in 1:days) {
    cases_day_j <- list()
    for (i in 1:n) {
      cases_day_j[[length(cases_day_j) + 1]] <- total_cases[[i]][[j]]
    }
    reorganized_cases[[length(reorganized_cases) + 1]] <- cases_day_j
  }
  return(reorganized_cases)
}
# Get average for cases per day
avg_cases_per_day <- function(reorganized_cases) {
  day_avgs <- list()
  for (i in 1:days) {
    avg_case <- mean(as.numeric(reorganized_cases[[i]]))
    avg_case_decimal <- avg_case - floor(avg_case)
    if (avg_case_decimal >= 0.5) {
      avg_case_int <- as.numeric(ceiling(avg_case))
    } else {
      avg_case_int <- as.numeric(floor(avg_case))
    }
    day_avgs[[length(day_avgs) + 1]] <- avg_case_int
  }
  return(day_avgs)
}
# Get standard deviation for cases per day
st_dev_cases_per_day <- function(reorganized_cases) {
  st_devs <- list()
  for (i in 1:days) {
    st_devs[[length(st_devs) + 1]] <- sd(as.numeric(reorganized_cases[[i]]))
  }
  return(st_devs)
}
# Get margins for confidence intervals for cases per day
margins_per_day <- function(reorganized_cases) {
  n <- length(reorganized_cases[[1]])
  margins <- list()
  for (i in 1:days) {
    st_dev <- sd(as.numeric(reorganized_cases[[i]]))
    margins[[length(margins) + 1]] <- qt(0.975, df=n-1) * st_dev / sqrt(n)
  }
  return(margins)
}
# Use this function to graph average cases per day over days in simulation
generate_graph <- function(reorganized_cases) {
  n <- length(reorganized_cases[1])
  avgs <- avg_cases_per_day(reorganized_cases)
  st_devs <- st_dev_cases_per_day(reorganized_cases)
  margins <- margins_per_day(reorganized_cases)
  upper <- as.numeric(avgs) - as.numeric(margins)
  lower <- as.numeric(avgs) + as.numeric(margins)
  
  x <- 1:days
  y <- as.numeric(avg_cases_per_day(reorganized_cases))
  data <- data.frame(x, y, lower, upper)
  
  plotCI(x = data$x,
         y = data$y,
         li = data$lower,
         ui = data$upper)
  lines(x, y)
}
# Run simulation for 40 repetitions
cases_per_day_multiple_simulations <- run_simulation_repeated(40, initial_state, testing, no_testing, semester)
# Calculate case projects per day across all 40 simulations
total_cases <- calculate_cases_multiple_simulations(40, cases_per_day_multiple_simulations)
# Reorganize case projection output for easier statistical analysis
reorganized_cases <- reorganize_total_cases(40, total_cases)
# Generate projection graph with confidence intervals
generate_graph(reorganized_cases)
```

## County-Level Validation (for Internal Purposes Only)

Before being able to run any validation on the county-level, please navigate to this website: https://experience.arcgis.com/experience/3d8eea39f5c1443db1743a4cb8948a9c and click the "Download Published Data" link in the top-left hand side of the GA DPH Vaccine Distribution Dashboard. An excel file titled "Georgia_DPH_PUBLIC_Vaccination_Public_Data_in_Excel.xlsx" should download. Please ensure that this file is saved to your working directory (essentially the directory where the the code for the entirety of the simulation model is located). The following code will not be able to function without completing that step. It should also be noted, that if you want the most current vaccination data, you will need to re-download this file and save it as "Georgia_DPH_PUBLIC_Vaccination_Public_Data_in_Excel.xlsx" in order for the following block of code to use the most updated data. 

The contents of this file contains the percentage of fully vaccinated individuals for each county in the state of Georgia. The "vaccination_data" variable reads the excel file into R and refers to the data stored in the "COUNTY_SUMMARY" sheet. Line 806 then attaches the column headers of that sheet so that we are able to refer to the column headers by their name as opposed to vaccination_data\$HEADER_NAME (for example we can simply call "COUNTY_NAME" as opposed to vaccination_data\$COUNTY_NAME). Line 807 selects only the columns of importance to us for county-level validation which are COUNTY_NAME (which refers to column containing the county names) and PCTCUMPCVAX (which refers to the corresponding percentage of individuals who have been fully vaccinated in that county). Line 808 removes the 1st row and the 161st row as the first row is the percentage for the entire state and the 161st row corresponds to an "unknown" county. Line 812 then converts the percentages for each county to a decimal and stores the percentages for each county in a single variable known as "percent_county_vaccinated". 
lines 814 - 822 set the initial states on the county-level. The initial susceptible population is set by calling the "initial_susceptibility" function and passes in the county_data as an input. This susceptible population is then split into vaccinated (S_0_v) and (S_0_n) using the "percent_county_vaccinated" gained from the DPH data on vaccination percentages by county. The initial infected states (I_sv, I_sn, I_av, I_an) are then determined by calling on the "initial_infected_symptomatic" and "initial_infected_asymptomatic" functions and then split between vaccinated and not vaccinated for both symptomatic and asymptomatic according the proportions specified in the vaccination data by the "percent_county_vaccinated" variable. The initial recovered unknown state is set by calling the "initial_recovered_unknown" function defined previously and passes in "county_data" as the input. Lastly, to ensure that sum of the proportions for each of these state equals 1, the county_data$total variable is instantiated and sums the previous state values. 

Lines 826-838 define a function called "generate_predicted_county_cases" which takes in the county_data as a parameter. It first instantiates a variable "predicted_cases" which will be used to store the predicted number of cases for each county in a list. The function then iterates through each row of the county_data (essential looping through the values for each county) using a for-loop. The first line of the for-loop, captures one row of data (or data for one county, rather) by indexing the county_data variable based on the current iteration "i". It then sets the "initial_state" variable necessary to run the simulation to the values for that specific row of data / county. Next, the instantiated baseline variable calls the "run_simulation" function, passing in the initial_state variable we just defined, and the testing, no_testing, and semester variables defined in lines 460-512. The final proportions for each state on the end of the 14 days are then captured and stored in the "two_week_state" variable by indexing the 14th row of data from the "baseline" variable. It should be noted that if you wish the validate on a county-level using a period other than 14 days, the days and semester variables would need to be updated to reflect the desired number of days, and the "two_week_state" variable would need index the baseline variables for the desired length. For example, if you wish to run validation for 28 days, the following changes would need to be made: 

days <- 28

semester <- seq(1, days, by=1)

two_week_state <- baseline[[28]]

Next, in order to calculate the overall infection attack rate and ultimately the number of predicted cases, we need to isolate the final proportions for the susceptible state as the infection attack rate is calculated by taking the difference in proportions of the susceptible state from the start of the simulation to the end of the simulation duration. This is seen in the variable "final_susceptibility" which indexes the last day of the simulations proportion (stored in the "two_week_state" variable) and sums the proportions from the susceptible, vaccinated and susceptible, not vaccinated states to get the total proportion of the population in the susceptible state on the last day of the simulation period. The infection attack rate is then calculated and stored by summing the initial values of the susceptible states (as referred to by row\$S_0_v + row\$S_0_n) and subtracts the final susceptibility proportion "final_susceptibility". The number of cases is then calculated by taking the ceiling of the multiplication of the infection_attack_rate * the population of the county. 

Our team also decided to standardize the number of predicted and observed cases to try and account for county population, so the standardized number of cases is calculated and stored in the "standardized_number_of_cases" variable and is calculated by taking the number of cases, dividing by the county population (row\$population) and then multiplying by 100,000. This standardized number of cases is then added to the predicted cases list. This process is repeated for each county by way of the for-loop's functionality. Finally, the function returns the list of standardized predicted cases. It should be noted that the list returned does not have any county names associated with it, which is why a helper function which ties the contents of this list to the respective county is necessary. 

This helper function is known as "populate_predicted_county_cases" and takes in two lists as its parameters. The first list, list1, should refer to a list of county names, while the second list, list2, should refer to the list of standardized predicted county cases. The first line of this function instantiates a dictionary called "predicted_county_cases". The function then iterates through the contents of list1 (list of county names") and obtains a specific county name by indexing the contents of list 1 (list1[[i]]) and its predicted number of cases by indexing the contents of list 2 (list2[[i]]). The function then checks to see if the county_name key already exists in the dictionary, and it if does, it skips out of the if-statement and then adds the county_name as the key with the predicted number of cases as the value to the "predicted_county_cases" dictionary. This process is repeated for each county. It should be noted that both the county names from list 1 and the predicted cases from list 2 are stored in order so the when adding to the dictionary, the right county is in fact being paired with the correct number of predicted cases. Lastly, the dictionary is returned. The number of standardized predicted cases connected to it's corresponding county can be seen in the "results" variable, which calls the "populate_predicted_county_cases" function with the keys of the "counties" dictionary instantiated in previous code (which is a list of the county names only) as the first list, and the results from the "generate_predicted_county_cases(county_data)" as the second list. 

Next, we must obtain and standardize the the observed number of cases, which is completed in line 874. This line of code also uses the "populate_predicted_county_cases" function, but instead passes into the function the standardized observed number of cases as the second list. The standardized number of observed cases is calculated by multiplying the number of cases in the past 14 days for the county (county_data\$X14.day.cases), divides by the respective county population (county_data\$population), and then multiplies this by 100,000. 

The difference between the standardized number of predicted cases and the standardized number of observed cases is calculated and stored in the "difference" variable. Lines 879-881 calculate the difference, the absolute difference, and percent error for each county. 

Next, a data frame table is created to display the county name, the number of standardized predicted cases, the number of standardized observed cases, the difference in these number of cases, and the overall percent error for each county. This is done by calling R's "matrix" function, setting the data to a list of lists using the c() function to turn the number of standardized predicted cases, the number of standardized observed cases, the difference in these number of cases, and the overall percent error for each county into one large table. We then need to assign the county names to each row which can be done using the "rownames(table)" function which passes in the "validation_table" variable and specifies that we wish to use the county_names for the row names. We then set column names to denote which column refers to which list of data, as seen by the following line of code: 

colnames(validation_table) <- c("predicted", "observed", "difference", "percent_error")

Lastly, lines 892-893 transform the matrix into a data frame table and attach the column names to the data using the attach() function. 

Because some of the model's predictions were exactly matching the observed number of cases, some of the counties experience 0 or NaN (errored) percent error, which will not allow us to manipulated the data or run averages for the difference or percent error. For this reason, we have split the counties up by those experience 0 difference between the standardized predicted number of cases and the standardized observed number of cases (stored in the no_error_counties variables), and those experiencing differences (stored in the error_counties variable). We can then calculate the average difference and the average percent error across all counties by calling "mean(difference)" and "mean(error_counties$percent_error)". It should be noted that if the mean difference is a positive value, this indicates that the model is, on average, over-predicting the number of cases, and if the mean difference is a negative value, this indicates that the model is, on average, under-predicting the number of cases. 

If you wish to calibrate the model, our suggestion is changing some of the values of the parameters specifed in 460-510. It is important to note that from previous calibration methods, the values of the beta values, gamma, masking compliance, and testing percentages seem to enact the greatest amount of change on the results of simulation model. 

Lastly, a histogram of residuals which displays the frequency of the "difference" values across the counties. From the validation conducted, the most frequent differences are centered around 0 which indicates that for a majority of the counties, the model is performing well and the difference in the number of predicted cases against the observed cases is relatively low. 

```{r}
library(ggplot2)
library(readxl)

vaccination_data <- read_excel("/Users/carolinedevlin/GDPH/Georgia_DPH_PUBLIC_Vaccination_Public_Data_in_Excel.xlsx", sheet = "COUNTY_SUMMARY", col_names = TRUE)
attach(vaccination_data)
vaccination_data <- subset(vaccination_data, select = c(COUNTY_NAME, PCTCUMPCVAX))
vaccination_data <- vaccination_data[-c(1, 161),]

percent_county_vaccinated = as.numeric(vaccination_data$PCTCUMPCVAX)/100

county_data$S_0 <- initial_susceptibility(county_data)
county_data$S_0_v <- (county_data$S_0)*percent_county_vaccinated
county_data$S_0_n <- (county_data$S_0)*(1 - percent_county_vaccinated)
county_data$I_sv <- (percent_county_vaccinated)*initial_infected_symptomatic(county_data)
county_data$I_sn <- (1 - percent_county_vaccinated)*initial_infected_symptomatic(county_data)
county_data$I_av <- (percent_county_vaccinated)*initial_infected_asymptomatic(county_data)
county_data$I_an <- (1 - percent_county_vaccinated)*initial_infected_asymptomatic(county_data)
county_data$R_u <- initial_recovered_unknown(county_data)
county_data$total <- county_data$S_0_v + county_data$S_0_n + county_data$I_sv + county_data$I_av + county_data$I_sn + county_data$I_an + county_data$R_u

generate_predicted_county_cases <- function(county_data) {
  predicted_cases <- c()
  for (i in 1:nrow(county_data)) {
    row <- county_data[i,]
    initial_state <- c(S_0_v = row$S_0_v, S_0_n = row$S_0_n, I_av = row$I_av,  I_an = row$I_an, I_sv = row$I_sv, I_sn = row$I_sn, TFN_a = TFN_a, TFN_s = TFN_s, TISO_an = TISO_an, TISO_sn = TISO_sn, TISO_ap = TISO_ap, TISO_sp = TISO_sp, RC = R_c, RU = row$R_u)
    baseline <- run_simulation(initial_state, testing, no_testing, semester)
    two_week_state <- baseline[[14]]
    final_susceptibility <- two_week_state["S_0_v"] + two_week_state["S_0_n"]
    infection_attack_rate <- (row$S_0_v + row$S_0_n) - final_susceptibility
    number_of_cases <- ceiling(infection_attack_rate * row$population)
    standardized_number_of_cases <- ceiling((number_of_cases/row$population)*100000)
    predicted_cases <- c(predicted_cases, standardized_number_of_cases)
  }
  return(predicted_cases)
}

populate_predicted_county_cases<- function(list1, list2) {
  predicted_county_cases <- hash()
  for (i in 1:length(list1)) {
    county_name <- list1[[i]]
    predicted_cases <- list2[[i]]
    if (has.key(county_name, predicted_county_cases)) {
      next
    }
    predicted_county_cases[county_name] <- predicted_cases
  }
  return(predicted_county_cases)
}

results <- populate_predicted_county_cases(keys(counties), generate_predicted_county_cases(county_data))

observed_cases <- populate_predicted_county_cases(keys(counties), ceiling((county_data$X14.day.cases/county_data$population)*100000))


# calculating percent error 
difference <- values(results) - values(observed_cases)
abs_difference <- abs(values(observed_cases) - values(results))
percent_error <- (abs_difference / values(results))*100

validation_table <- matrix(data = c(values(results), values(observed_cases), difference, percent_error), ncol = 4)
rownames(validation_table) <- c(keys(results))
colnames(validation_table) <- c("predicted", "observed", "difference", "percent_error")
validation_table <- as.data.frame(validation_table)
attach(validation_table)

no_error_counties <- validation_table[validation_table$difference == 0, ]

error_counties <- validation_table[validation_table$difference != 0, ]

mean(difference)
mean(error_counties$percent_error)

ggplot(data = validation_table, aes(x = validation_table$difference)) +
    geom_histogram(fill = 'steelblue', color = 'black') +
    labs(title = 'Histogram of Residuals', x = 'Residuals', y = 'Frequency')
```